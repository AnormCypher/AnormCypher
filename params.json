{"name":"AnormCypher","tagline":"Cypher-oriented Scala library for Neo4j Server (REST)","body":"## AnormCypher\r\nThis is a Neo4j client library for the HTTP Cypher endpoints.\r\n\r\nThe goals of this library are to provide a great API to use Cypher, and it will be modeled after Anorm from Play,\r\nwhich I found to be pleasant to use with SQL. More info about Anorm can be found here:\r\nhttp://www.playframework.org/documentation/2.0.4/ScalaAnorm\r\n\r\nIntegration tests currently run against neo4j-community-2.0.3.\r\n\r\n[![Build Status](https://travis-ci.org/AnormCypher/AnormCypher.png?branch=master)](https://travis-ci.org/AnormCypher/AnormCypher?branch=master)\r\n\r\nAs of version 0.5, AnormCypher uses play-json and Scala 2.11. \r\n\r\nIf you want to use scala 2.10, you need to use version 0.4.x (latest is 0.4.4)\r\n\r\nIf you want to use scala 2.9, you need to use version 0.3.x (latest is 0.3.1).\r\n\r\n## SBT Console Demo\r\n\r\nSwitch to an empty folder and create a build.sbt file with the following:\r\n``` Scala\r\nresolvers ++= Seq(\r\n  \"anormcypher\" at \"http://repo.anormcypher.org/\",\r\n  \"Typesafe Releases\" at \"http://repo.typesafe.com/typesafe/releases/\"\r\n)\r\n\r\n\r\nlibraryDependencies ++= Seq(\r\n  \"org.anormcypher\" %% \"anormcypher\" % \"0.5.1\"\r\n)\r\n```\r\n\r\nRun `sbt console`\r\n\r\nAssuming you have a local Neo4j Server running on the default port, try (note: this will create nodes on your database):\r\n``` Scala\r\nimport org.anormcypher._\r\n\r\n// create some test nodes\r\nCypher(\"\"\"create (anorm {name:\"AnormCypher\"}), (test {name:\"Test\"})\"\"\").execute()\r\n\r\n// a simple query\r\nval req = Cypher(\"start n=node(*) return n.name\")\r\n\r\n// get a stream of results back\r\nval stream = req()\r\n\r\n// get the results and put them into a list\r\nstream.map(row => {row[String](\"n.name\")}).toList\r\n```\r\n\r\n## Usage\r\nYou'll probably notice that this usage is very close to Play's Anorm. That is the idea!\r\n\r\n### Configuring a server\r\nThe default is localhost, but you can specify a special server when your app is starting via the `setServer` or `setURL` \r\noptions.\r\n``` Scala\r\nimport org.anormcypher._\r\n\r\n// without auth\r\nNeo4jREST.setServer(\"localhost\", 7474, \"/db/data/\")\r\n\r\n// or with basic auth\r\nNeo4jREST.setServer(\"localhost\", 7474, \"/db/data/\", \"username\", \"password\")\r\n```\r\n\r\nFor 1.8.x or older, you may need to specify a cypher endpoint like so (the default goes to the 1.9/2.0 style endpoint):\r\n\r\n```\r\nNeo4jREST.setServer(\"localhost\", 7474, \"/db/data/\", \"ext/CypherPlugin/graphdb/execute_query\")\r\n```\r\n\r\n### Executing Cypher Queries\r\n\r\nTo start you need to learn how to execute Cypher queries.\r\n\r\nFirst, `import org.anormcypher._`, and then simply use the Cypher object to create queries. \r\n\r\n``` Scala\r\nimport org.anormcypher._ \r\n\r\nval result: Boolean = Cypher(\"START n=node(0) RETURN n\").execute()    \r\n```\r\n\r\nThe `execute()` method returns a Boolean value indicating whether the execution was successful.\r\n\r\nTo execute an update, you can use executeUpdate(), which returns the number of `(Nodes, Relationships, Properties)` updated. Note: NOT SUPPORTED YET.\r\n\r\n`val result: (Int, Int, Int) = Cypher(\"START n=node(0) DELETE n\").executeUpdate()`\r\n\r\nSince Scala supports multi-line strings, feel free to use them for complex Cypher statements:\r\n\r\n``` Scala\r\n// create some sample data\r\nval result = Cypher(\"\"\"\r\n  create (germany {name:\"Germany\", population:81726000, type:\"Country\", code:\"DEU\"}),\r\n         (france {name:\"France\", population:65436552, type:\"Country\", code:\"FRA\", indepYear:1790}),\r\n         (monaco {name:\"Monaco\", population:32000, type:\"Country\", code:\"MCO\"});\r\n  \"\"\").execute()\r\n// result: Boolean = true\r\n \r\nval cypherQuery = Cypher(\r\n  \"\"\"\r\n    start n=node(*) \r\n    match n-->m\r\n    where n.code = 'FRA';\r\n    return n,m;\r\n  \"\"\"\r\n)\r\n```\r\n\r\nIf your Cypher query needs dynamic parameters, you can declare placeholders like `{name}` in the query string, and later assign a value to them with `on`:\r\n\r\n``` Scala\r\nCypher(\r\n  \"\"\"\r\n    start n=node(*) \r\n    where n.type = \"Country\"\r\n      and n.code = {countryCode}\r\n    return n.name\r\n  \"\"\"\r\n).on(\"countryCode\" -> \"FRA\")\r\n```\r\n\r\n### Retrieving data using the Stream API\r\nThe first way to access the results of a return query is to use the Stream API.\r\n\r\nWhen you call `apply()` on any Cypher statement, you will receive a lazy `Stream` of `CypherRow` instances, where each row can be seen as a dictionary:\r\n\r\n``` Scala\r\n// Create Cypher query\r\nval allCountries = Cypher(\"start n=node(*) where n.type = 'Country' return n.code as code, n.name as name\")\r\n \r\n// Transform the resulting Stream[CypherRow] to a List[(String,String)]\r\nval countries = allCountries.apply().map(row => \r\n  row[String](\"code\") -> row[String](\"name\")\r\n).toList\r\n```\r\n\r\nIn the following example we will count the number of Country entries in the database, so the result set will be a single row with a single column:\r\n\r\n``` Scala\r\n// First retrieve the first row\r\nval firstRow = Cypher(\"start n=node(*) where n.type = 'Country' return count(n) as c\").apply().head\r\n \r\n// Next get the content of the 'c' column as Long\r\nval countryCount = firstRow[Long](\"c\")\r\n// countryCount: Long = 3\r\n```\r\n\r\n### Using Pattern Matching\r\nYou can also use Pattern Matching to match and extract the CypherRow content. In this case the column name doesn’t matter. Only the order and the type of the parameters is used to match.\r\n\r\nThe following example transforms each row to the correct Scala type:\r\n\r\n``` Scala\r\ncase class SmallCountry(name:String) \r\ncase class BigCountry(name:String) \r\ncase class France\r\n\r\n// NOTE: case CypherRow syntax is NOT YET SUPPORTED\r\nval countries = Cypher(\"start n=node(*) where n.type = 'Country' return n.name as name, n.population as pop\")().collect {\r\n  case CypherRow(\"France\", _) => France()\r\n  case CypherRow(name:String, pop:Int) if(pop > 1000000) => BigCountry(name)\r\n  case CypherRow(name:String, _) => SmallCountry(name)      \r\n}\r\n// countries: scala.collection.immutable.Stream[Product with Serializable] = Stream(BigCountry(Germany), ?)\r\n\r\nval countryList = countries.toList\r\n// countryList: List[Product with Serializable] = List(BigCountry(Germany), France(), SmallCountry(Monaco))\r\n```\r\n\r\nNote that since `collect(…)` ignores the cases where the partial function isn’t defined, it allows your code to safely ignore rows that you don’t expect.\r\n\r\n### Special data types\r\n#### Nodes\r\n\r\nNodes can be extracted as so:\r\n\r\n``` Scala\r\n// NOTE: case CypherRow syntax is NOT YET SUPPORTED\r\nCypher(\"start n=node(*) where n.type = 'Country' return n.name as name, n\")().map {\r\n  case CypherRow(name: String, n: org.anormcypher.NeoNode) => name -> n\r\n}\r\n```  \r\nHere we specifically chose to use map, as we want an exception if the row isn’t in the format we expect.\r\n\r\nA `Node` is just a simple Scala `case class`, not quite as type-safe as configuring your own:\r\n``` Scala\r\ncase class NeoNode(id:Int, props:Map[String,Any])\r\n```\r\n\r\n#### Relationships\r\n\r\nRelationships can be extracted as so:\r\n\r\n``` Scala\r\n// NOTE: case CypherRow syntax is NOT YET SUPPORTED\r\nCypher(\"start n=node(*) match n-[r]-m where has(n.name) return n.name as name, r;\")().map {\r\n  case CypherRow(name: String, r: org.anormcypher.NeoRelationship) => name -> r\r\n}\r\n```  \r\nHere we specifically chose to use map, as we want an exception if the row isn’t in the format we expect.\r\n\r\nSimilarly, a `Relationship` is just a simple Scala `case class`, not quite as type-safe as configuring your own:\r\n``` Scala\r\ncase class NeoRelationship(id:Int, props:Map[String,Any])\r\n```\r\n\r\n### Dealing with Nullable columns\r\nIf a column can contain `Null` values in the database schema, you need to manipulate it as an `Option` type.\r\n\r\nFor example, the `indepYear` of the `Country` table is nullable, so you need to match it as `Option[Int]`:\r\n\r\n``` Scala\r\n// NOTE: case CypherRow syntax is NOT YET SUPPORTED\r\nCypher(\"start n=node(*) where n.type = 'Country' return n.name as name, n.indepYear as year;\")().collect {\r\n  case CypherRow(name:String, Some(year:Int)) => name -> year\r\n}\r\n```\r\n\r\nIf you try to match this column as `Int` it won’t be able to parse `Null` values. Suppose you try to retrieve the column content as `Int` directly from the dictionary:\r\n``` Scala\r\nCypher(\"start n=node(*) where n.type = 'Country' return n.name as name, n.indepYear as indepYear;\")().map { row =>\r\n  row[String](\"name\") -> row[Int](\"indepYear\")\r\n}\r\n```\r\n\r\nThis will produce an `UnexpectedNullableFound(COUNTRY.INDEPYEAR)` exception if it encounters a null value, so you need to map it properly to an `Option[Int]`, as:\r\n\r\n``` Scala\r\nCypher(\"start n=node(*) where n.type = 'Country' return n.name as name, n.indepYear as indepYear;\")().map { row =>\r\n  row[String](\"name\") -> row[Option[Int]](\"indepYear\")\r\n}\r\n```\r\n\r\nThis is also true for the parser API, as we will see next.\r\n\r\n### Using the Parser API (the Parser API is a work in progress)\r\nYou can use the parser API to create generic and reusable parsers that can parse the result of any Cypher query.\r\n\r\nNote: This is really useful, since most queries in a web application will return similar data sets. For example, if you have defined a parser able to parse a Country from a result set, and another Language parser, you can then easily compose them to parse both Country and Language from a single return.\r\n\r\nFirst you need to import `org.anormcypher.CypherParser._`\r\n\r\nFirst you need a `CypherRowParser`, i.e. a parser able to parse one row to a Scala value. For example we can define a parser to transform a single column result set row, to a Scala `Long`:\r\n\r\n``` Scala\r\nval rowParser = scalar[Long]\r\n```\r\n\r\nThen we have to transform it into a `CypherResultSetParser`. Here we will create a parser that parse a single row:\r\n\r\n``` Scala\r\nval rsParser = scalar[Long].single\r\n```\r\n\r\nSo this parser will parse a result set to return a `Long`. It is useful to parse to results produced by a simple Cypher count query:\r\n\r\n``` Scala\r\nval count: Long = Cypher(\"start n=node(*) return count(n)\").as(scalar[Long].single)\r\n```\r\n\r\nLet’s write a more complicated parser:\r\n\r\n`str(\"name\") ~ int(\"population\")`, will create a `CypherRowParser` able to parse a row containing a `String` name column and an `Integer` population column. Then we can create a `ResultSetParser` that will parse as many rows of this kind as it can, using *:\r\n\r\n``` Scala\r\nval populations:List[String~Int] = {\r\n  Cypher(\"start n=node(*) where n.type = 'Country' return n.*\").as( str(\"n.name\") ~ int(\"n.population\") * ) \r\n}\r\n```\r\n\r\nAs you see, this query’s result type is `List[String~Int]` - a list of country name and population items.\r\n\r\nYou can also rewrite the same code as:\r\n\r\n``` Scala\r\nval result:List[String~Int] = {\r\n  Cypher(\"start n=node(*) where n.type = 'Country' return n.*\").as(get[String](\"n.name\")~get[Int](\"n.population\")*) \r\n}\r\n```\r\n\r\nNow what about the `String~Int` type? This is an AnormCypher type that is not really convenient to use outside of your database access code. You would rather have a simple tuple `(String, Int)` instead. You can use the map function on a `CypherRowParser` to transform its result to a more convenient type:\r\n\r\n``` Scala\r\nstr(\"n.name\") ~ int(\"n.population\") map { case n~p => (n,p) }\r\n```\r\n\r\nNote: We created a tuple `(String,Int)` here, but there is nothing stopping you from transforming the `CypherRowParser` result to any other type, such as a custom case class.\r\n\r\nNow, because transforming `A~B~C` types to `(A,B,C)` is a common task, we provide a `flatten` function that does exactly that. So you finally write:\r\n\r\n``` Scala\r\nval result:List[(String,Int)] = {\r\n  Cypher(\"start n=node(*) where n.type = 'Country' return n.*\").as(\r\n    str(\"n.name\") ~ int(\"n.population\") map(flatten) *\r\n  ) \r\n}\r\n```\r\n\r\nNow let’s try with a more complicated example. How to parse the result of the following query to retrieve the country name and all spoken languages for a country code?\r\n\r\n``` Cypher\r\nstart country=node_auto_index(code=\"FRA\")\r\nmatch country-[:speaks]->language\r\nreturn country.name, language.name;\r\n```\r\n\r\nLet's start by parsing all rows as a `List[(String,String)]` (a list of name,language tuples):\r\n\r\n``` Scala\r\nvar p: CypherResultSetParser[List[(String,String)] = {\r\n  str(\"country.name\") ~ str(\"language.name\") map(flatten) *\r\n}\r\n```\r\n\r\nNow we get this kind of result:\r\n\r\n``` Scala\r\nList(\r\n  (\"France\", \"Arabic\"), \r\n  (\"France\", \"French\"), \r\n  (\"France\", \"Italian\"), \r\n  (\"France\", \"Portuguese\"), \r\n  (\"France\", \"Spanish\"), \r\n  (\"France\", \"Turkish\")\r\n)\r\n```\r\n\r\nWe can then use the Scala collection API, to transform it to the expected result:\r\n\r\n``` Scala\r\ncase class SpokenLanguages(country:String, languages:Seq[String])\r\n\r\nlanguages.headOption.map { f =>\r\n  SpokenLanguages(f._1, languages.map(_._2))\r\n}\r\n```\r\n\r\nFinally, we get this convenient function:\r\n\r\n``` Scala\r\ncase class SpokenLanguages(country:String, languages:Seq[String])\r\n\r\ndef spokenLanguages(countryCode: String): Option[SpokenLanguages] = {\r\n  val languages: List[(String, String)] = Cypher(\r\n    \"\"\"\r\n      start country=node_auto_index(code=\"{code}\")\r\n      match country-[:speaks]->language\r\n      return country.name, language.name;\r\n    \"\"\"\r\n  )\r\n  .on(\"code\" -> countryCode)\r\n  .as(str(\"country.name\") ~ str(\"language.name\") map(flatten) *)\r\n\r\n  languages.headOption.map { f =>\r\n    SpokenLanguages(f._1, languages.map(_._2))\r\n  }\r\n}\r\n```\r\n\r\nTo continue, let’s complicate our example to separate the official language from the others:\r\n\r\n``` Scala\r\ncase class SpokenLanguages(\r\n  country:String, \r\n  officialLanguage: Option[String], \r\n  otherLanguages:Seq[String]\r\n)\r\n\r\ndef spokenLanguages(countryCode: String): Option[SpokenLanguages] = {\r\n  val languages: List[(String, String, Boolean)] = Cypher(\r\n    \"\"\"\r\n      start country=node_auto_index(code=\"{code}\")\r\n      match country-[:speaks]->language\r\n      return country.name, language.name, language.isOfficial;\r\n    \"\"\"\r\n  )\r\n  .on(\"code\" -> countryCode)\r\n  .as {\r\n    str(\"country.name\") ~ str(\"language.name\") ~ str(\"language.isOfficial\") map {\r\n      case n~l~\"T\" => (n,l,true)\r\n      case n~l~\"F\" => (n,l,false)\r\n    } *\r\n  }\r\n\r\n  languages.headOption.map { f =>\r\n    SpokenLanguages(\r\n      f._1, \r\n      languages.find(_._3).map(_._2),\r\n      languages.filterNot(_._3).map(_._2)\r\n    )\r\n  }\r\n}\r\n```\r\n\r\nIf you try this on the world sample database, you will get:\r\n\r\n``` Scala\r\n$ spokenLanguages(\"FRA\")\r\n> Some(\r\n    SpokenLanguages(France,Some(French),List(\r\n      Arabic, Italian, Portuguese, Spanish, Turkish\r\n    ))\r\n)\r\n```\r\n\r\n## Contributors\r\n* Wes Freeman: @wfreeman on github\r\n* Jason Jackson: @jasonjackson on github\r\n* Julien Sirocchi: @sirocchj on github\r\n* Pieter-Jan Van Aeken: @PieterJanVanAeken on github\r\n* @okumin on github\r\n* @mvallerie on github\r\n* Denis Rosca: @denisrosca on github\r\n\r\n## Thanks\r\n* The Play Framework team for providing the Anorm library, the basis for this library. (and now the play-json module)\r\n* Databinder.net, for the Dispatch library\r\n* Neo Technologies for Neo4j!\r\n\r\n## License LGPL\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU Lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU Lesser General Public License for more details.\r\n \r\nYou should have received a copy of the GNU Lesser General Public License\r\nalong with this program.  If not, see http://www.gnu.org/licenses/\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}